/**
 * Gemini Pre-Constraint Module
 *
 * Analyze formation transitions and provide constraints to algorithms
 */

import { callGeminiAPI } from './config';
import type { Position } from '../algorithms/hungarian';

/**
 * Movement order strategy
 */
export type MovementOrder =
  | 'simultaneous'    // Simultaneous movement
  | 'wave_outward'    // Wave from outside
  | 'wave_inward'     // Wave from inside
  | 'center_first'    // Center first
  | 'outer_first'     // Outer first
  | 'longest_first'   // Longest distance first
  | 'shortest_first'; // Shortest distance first

/**
 * Individual dancer hint
 */
export interface DancerHint {
  dancerId: number;
  priority: number;       // Processing priority (lower = first)
  preferCurve: boolean;   // Prefer curved path
  delayRatio: number;     // Start delay ratio (0-1)
  avoidCenter: boolean;   // Avoid center
}

/**
 * Pre-constraints generated by Gemini
 */
export interface GeminiPreConstraint {
  // Overall strategy
  movementOrder: MovementOrder;
  overallStrategy: string;  // Natural language description

  // Individual dancer hints
  dancerHints: DancerHint[];

  // Additional constraints
  maintainSymmetry: boolean;     // Maintain symmetry
  avoidCrossing: boolean;        // Avoid path crossing
  preferSmoothPaths: boolean;    // Prefer smooth paths
  suggestedCurveAmount: number;  // Suggested curve amount (0-1)

  // Confidence
  confidence: number;  // 0-1
}

/**
 * Formation info
 */
interface FormationInfo {
  type: string;
  positions: Position[];
  centerX: number;
  centerY: number;
}

/**
 * Analyze formation (center, distribution, etc.)
 */
function analyzeFormation(positions: Position[], _stageWidth: number, _stageHeight: number): FormationInfo {
  const centerX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
  const centerY = positions.reduce((sum, p) => sum + p.y, 0) / positions.length;

  // Check circular
  const distancesFromCenter = positions.map(p =>
    Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2)
  );
  const avgDist = distancesFromCenter.reduce((a, b) => a + b, 0) / distancesFromCenter.length;
  const distVariance = distancesFromCenter.reduce((sum, d) => sum + (d - avgDist) ** 2, 0) / distancesFromCenter.length;
  const isCircular = distVariance < 0.5;

  // Check line
  const yVariance = positions.reduce((sum, p) => sum + (p.y - centerY) ** 2, 0) / positions.length;
  const isLine = yVariance < 0.5;

  // Check V-shape
  const sortedByX = [...positions].sort((a, b) => a.x - b.x);
  const leftHalf = sortedByX.slice(0, Math.floor(sortedByX.length / 2));
  const rightHalf = sortedByX.slice(Math.ceil(sortedByX.length / 2));
  const leftSlope = leftHalf.length > 1 ? (leftHalf[leftHalf.length - 1].y - leftHalf[0].y) / (leftHalf[leftHalf.length - 1].x - leftHalf[0].x) : 0;
  const rightSlope = rightHalf.length > 1 ? (rightHalf[rightHalf.length - 1].y - rightHalf[0].y) / (rightHalf[rightHalf.length - 1].x - rightHalf[0].x) : 0;
  const isVShape = leftSlope > 0.3 && rightSlope < -0.3;

  let type = 'unknown';
  if (isCircular) type = 'circle';
  else if (isLine) type = 'line';
  else if (isVShape) type = 'v_shape';

  return { type, positions, centerX, centerY };
}

/**
 * Generate prompt
 */
function createPreConstraintPrompt(
  startInfo: FormationInfo,
  endInfo: FormationInfo,
  dancerCount: number,
  stageWidth: number,
  stageHeight: number
): string {
  const startPositionsStr = startInfo.positions
    .map((p, i) => `  Dancer ${i + 1}: (${p.x.toFixed(1)}, ${p.y.toFixed(1)})`)
    .join('\n');

  const endPositionsStr = endInfo.positions
    .map((p, i) => `  Dancer ${i + 1}: (${p.x.toFixed(1)}, ${p.y.toFixed(1)})`)
    .join('\n');

  return `You are a professional dance choreographer. Analyze the formation transition and suggest the optimal movement strategy.

## Stage Info
- Size: ${stageWidth}m x ${stageHeight}m
- Center: (${stageWidth / 2}, ${stageHeight / 2})

## Start Formation (${startInfo.type})
${startPositionsStr}
- Formation center: (${startInfo.centerX.toFixed(1)}, ${startInfo.centerY.toFixed(1)})

## End Formation (${endInfo.type})
${endPositionsStr}
- Formation center: (${endInfo.centerX.toFixed(1)}, ${endInfo.centerY.toFixed(1)})

## Analysis Request
1. What is the most natural movement order for this formation transition?
2. Which dancers should move first/last?
3. Which dancers need curved paths?
4. Is path crossing avoidance necessary?

## Response Format (JSON only)
{
  "movementOrder": "simultaneous" | "wave_outward" | "wave_inward" | "center_first" | "outer_first" | "longest_first" | "shortest_first",
  "overallStrategy": "Overall strategy description (1-2 sentences)",
  "dancerHints": [
    {
      "dancerId": 1,
      "priority": 1,
      "preferCurve": false,
      "delayRatio": 0.0,
      "avoidCenter": false
    }
  ],
  "maintainSymmetry": true/false,
  "avoidCrossing": true/false,
  "preferSmoothPaths": true/false,
  "suggestedCurveAmount": 0.0-1.0,
  "confidence": 0.0-1.0
}

Notes:
- dancerHints must be provided for all ${dancerCount} dancers
- priority starts from 1, lower = processed first
- delayRatio is 0 (start immediately) to 1 (start last)
- Return JSON only, no explanation`;
}

/**
 * Extract JSON
 */
function extractJSON(text: string): string {
  const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonMatch) {
    return jsonMatch[1].trim();
  }

  const trimmed = text.trim();
  if (trimmed.startsWith('{')) {
    return trimmed;
  }

  throw new Error('JSON not found.');
}

/**
 * Generate default constraint (local fallback)
 */
export function generateDefaultConstraint(
  startPositions: Position[],
  endPositions: Position[],
  stageWidth: number,
  stageHeight: number
): GeminiPreConstraint {
  const dancerCount = startPositions.length;
  const stageCenterX = stageWidth / 2;
  const stageCenterY = stageHeight / 2;

  // Calculate movement distance for each dancer
  const distances = startPositions.map((start, i) => ({
    dancerId: i + 1,
    distance: Math.sqrt(
      (endPositions[i].x - start.x) ** 2 +
      (endPositions[i].y - start.y) ** 2
    ),
    startDistFromCenter: Math.sqrt(
      (start.x - stageCenterX) ** 2 +
      (start.y - stageCenterY) ** 2
    ),
  }));

  // Sort by distance and assign priority
  const sortedByDistance = [...distances].sort((a, b) => b.distance - a.distance);

  const dancerHints: DancerHint[] = distances.map(d => {
    const priority = sortedByDistance.findIndex(s => s.dancerId === d.dancerId) + 1;
    return {
      dancerId: d.dancerId,
      priority,
      preferCurve: d.distance > 3,  // Consider curve for long distance
      delayRatio: (priority - 1) / (dancerCount - 1) * 0.3,  // Max 30% delay
      avoidCenter: d.startDistFromCenter < 2,  // Dancers near center avoid center
    };
  });

  return {
    movementOrder: 'longest_first',
    overallStrategy: 'Process dancers with longer distances first to minimize collisions',
    dancerHints,
    maintainSymmetry: true,
    avoidCrossing: true,
    preferSmoothPaths: true,
    suggestedCurveAmount: 0.3,
    confidence: 0.5,  // Low confidence for local fallback
  };
}

/**
 * Generate pre-constraint using Gemini
 */
export async function generatePreConstraint(
  startPositions: Position[],
  endPositions: Position[],
  stageWidth: number,
  stageHeight: number
): Promise<GeminiPreConstraint> {
  const startInfo = analyzeFormation(startPositions, stageWidth, stageHeight);
  const endInfo = analyzeFormation(endPositions, stageWidth, stageHeight);

  const prompt = createPreConstraintPrompt(
    startInfo,
    endInfo,
    startPositions.length,
    stageWidth,
    stageHeight
  );

  try {
    const responseText = await callGeminiAPI(prompt, { temperature: 0.3 });
    const jsonStr = extractJSON(responseText);
    const result = JSON.parse(jsonStr) as GeminiPreConstraint;

    // Validation and apply defaults
    if (!result.dancerHints || result.dancerHints.length !== startPositions.length) {
      throw new Error('Invalid dancerHints');
    }

    return {
      movementOrder: result.movementOrder || 'simultaneous',
      overallStrategy: result.overallStrategy || '',
      dancerHints: result.dancerHints,
      maintainSymmetry: result.maintainSymmetry ?? true,
      avoidCrossing: result.avoidCrossing ?? true,
      preferSmoothPaths: result.preferSmoothPaths ?? true,
      suggestedCurveAmount: result.suggestedCurveAmount ?? 0.3,
      confidence: result.confidence ?? 0.8,
    };
  } catch (error) {
    console.error('Gemini Pre-constraint generation failed:', error);
    // Fallback: local constraint
    return generateDefaultConstraint(startPositions, endPositions, stageWidth, stageHeight);
  }
}
